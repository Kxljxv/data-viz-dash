
class GraphVisualization {
    constructor() {
        this.canvas = d3.select('#graph-canvas');
        const canvasNode = this.canvas.node();
        
        if (!canvasNode) {
            console.warn('Canvas element #graph-canvas not found. Retrying in 100ms...');
            setTimeout(() => this.init(), 100);
            return;
        }

        this.init();
    }

    init() {
        if (this.initialized) return;
        this.initialized = true;

        this.canvas = d3.select('#graph-canvas');
        const canvasNode = this.canvas.node();
        this.ctx = canvasNode.getContext('2d');
        this.width = window.innerWidth;
        this.height = window.innerHeight;

        this.canvas.attr('width', this.width).attr('height', this.height);

        this.selectedNode = null;
        this.hoveredNode = null;
        this.groups = [];
        this.nodeGroups = new Map();
        this.selectedColor = '#7f6df2';
        this.defaultFont = 'modern_dense';
        this.currentGroupForSearch = null;
        this.transform = d3.zoomIdentity;
        this.selectedAntragCode = null;
        this.motionUrlMap = {};
        this.currentPdfCode = null;
        this.eventsInitialized = false;

        this.settings = {
            showLabels: false,
            showLinks: true,
            showAntraege: true,
            showSupporters: true,
            nodeSize: 1
        };

        this.zoom = d3.zoom()
            .scaleExtent([0.01, 10])
            .on('zoom', (event) => {
                this.transform = event.transform;
                this.render();
            });

        d3.select(canvasNode)
            .call(this.zoom)
            .on('dblclick.zoom', null);

        // Selection handler using click (which is suppressed by D3 zoom on drag)
        d3.select(canvasNode).on('click', (event) => {
            // Check if this click event was generated by a drag/pan
            if (event.defaultPrevented) return;
            
            const node = this.findNodeAt(event);
            if (node) {
                this.onNodeClick(event, node);
            } else {
                this.deselectAll();
            }
        });

        d3.select(canvasNode).on('mousemove', (event) => {
            const node = this.findNodeAt(event);
            if (node !== this.hoveredNode) {
                this.hoveredNode = node;
                this.render();
            }
        });

        d3.select(canvasNode).on('contextmenu', (event) => {
            event.preventDefault();
            const node = this.findNodeAt(event);
            if (node) this.showNodeContextMenu(event, node);
        });

        this.loadData();
    }

    getFontClass(fontName) {
        const fontMap = {
            'dyslexic': 'font-dyslexic',
            'modern_dense': 'font-modern-dense',
            'modern_wide': 'font-modern-wide',
            'serif': 'font-serif'
        };
        return fontMap[fontName] || fontMap[this.defaultFont];
    }

    deselectAll() {
        this.selectedNode = null;

        // Dispatch custom event to clear selection in React
        window.dispatchEvent(new CustomEvent('aea-node-selected', {
            detail: { node: null }
        }));

        if (this.nodeElements) {
            this.nodeElements.classed('selected', false).classed('dimmed', false);
            this.linkGroup.selectAll('.link').classed('dimmed', false);
            this.labelElements.classed('dimmed', false);
        }
        this.updateLabelVisibility();
        this.render();
    }

    async loadData() {
        try {
            // Get project from URL parameters, default to 'bdk'
            const urlParams = new URLSearchParams(window.location.search);
            const project = urlParams.get('project') || 'bdk';
            
            const response = await fetch(`/data/${project}/data.json`);
            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status}`);
            }
            const data = await response.json();
            this.data = data;
            this.metadata = data.metadata || {};

            this.processData();
            this.setupEventListeners();
            await this.simulatePhysics(); // Await this to ensure positions are loaded

        } catch (error) {
            console.error('Fehler beim Laden der Daten:', error);
            const loadingOverlay = document.getElementById('loading');
            if (loadingOverlay) loadingOverlay.innerHTML = `<div class="text-red-500">Fehler beim Laden: ${error.message}</div>`;
        }
    }

    processData() {
        const nodeMap = new Map();
        const links = [];

        const antragColor = getComputedStyle(document.documentElement).getPropertyValue('--node-amendment').trim() || '#d86b74';
        const supporterColor = getComputedStyle(document.documentElement).getPropertyValue('--node-supporter').trim() || '#7dff00';

        const getSupporterId = (name, kv) => {
            if (!name) return null;
            const cleanName = name.trim();
            const cleanKv = (kv || '').trim();
            return cleanKv ? `${cleanName} | ${cleanKv}` : cleanName;
        };

        if (this.data && typeof this.data === 'object' && !Array.isArray(this.data) && !this.data.motions) {
            Object.entries(this.data).forEach(([key, val]) => {
                // Skip metadata or other non-motion keys if they exist
                if (key === 'metadata' || !val || typeof val !== 'object') return;

                const aeaId = val.application_id || val.id || key;
                const aeaLabel = (Array.isArray(val.heading) ? val.heading[0] : val.heading) || aeaId;
                
                if (!nodeMap.has(aeaId)) {
                    nodeMap.set(aeaId, { id: aeaId, label: aeaLabel, type: 'antrag', color: antragColor, linkCount: 0, font: this.defaultFont });
                }
                if (val.url) this.motionUrlMap[aeaId] = val.url;

                // Antragsteller (applicant)
                const applicant = val.applicant;
                if (applicant) {
                    let name, kv;
                    if (Array.isArray(applicant) && applicant.length >= 1) {
                        name = applicant[0];
                        kv = applicant[1];
                    } else if (typeof applicant === 'string') {
                        name = applicant;
                    }

                    const supporterId = getSupporterId(name, kv);
                    if (supporterId) {
                        if (!nodeMap.has(supporterId)) {
                            nodeMap.set(supporterId, { 
                                id: supporterId, 
                                label: name.trim(), 
                                sublabel: (kv || '').trim(), 
                                type: 'supporter', 
                                color: supporterColor, 
                                linkCount: 0, 
                                font: this.defaultFont 
                            });
                        }
                        links.push({ source: aeaId, target: supporterId, weight: 5 });
                        nodeMap.get(aeaId).linkCount += 5;
                        nodeMap.get(supporterId).linkCount += 5;
                    }
                }

                // UnterstÃ¼tzer (supporters)
                const supporters = Array.isArray(val.supporters) ? val.supporters : [];
                supporters.forEach(s => {
                    let name, kv;
                    if (Array.isArray(s) && s.length >= 1) {
                        name = s[0];
                        kv = s[1];
                    } else if (typeof s === 'string') {
                        name = s;
                    }

                    const supporterId = getSupporterId(name, kv);
                    if (supporterId) {
                        if (!nodeMap.has(supporterId)) {
                            nodeMap.set(supporterId, { 
                                id: supporterId, 
                                label: name.trim(), 
                                sublabel: (kv || '').trim(), 
                                type: 'supporter', 
                                color: supporterColor, 
                                linkCount: 0, 
                                font: this.defaultFont 
                            });
                        }
                        links.push({ source: aeaId, target: supporterId, weight: 1 });
                        nodeMap.get(aeaId).linkCount += 1;
                        nodeMap.get(supporterId).linkCount += 1;
                    }
                });
            });
        } else if (this.data.motions && Array.isArray(this.data.motions)) {
            this.data.motions.forEach(m => {
                const aea = m.code || m.title || m.antrag || m.id;
                if (!aea) return;
                if (!nodeMap.has(aea)) {
                    nodeMap.set(aea, { id: aea, label: aea, type: 'antrag', color: antragColor, linkCount: 0, font: this.defaultFont });
                }
                if (m.url) this.motionUrlMap[aea] = m.url;
                const app = m.applicant;
                if (app && Array.isArray(app) && app.length >= 1) {
                    const supporterId = `${app[0]} | ${app[1] || ''}`;
                    if (!nodeMap.has(supporterId)) {
                        nodeMap.set(supporterId, { id: supporterId, label: app[0], sublabel: app[1] || '', type: 'supporter', color: supporterColor, linkCount: 0, font: this.defaultFont });
                    }
                    links.push({ source: aea, target: supporterId, weight: 5 });
                    nodeMap.get(aea).linkCount += 5;
                    nodeMap.get(supporterId).linkCount += 5;
                }
                (m.supporters || []).forEach(s => {
                    const supporterId = `${s[0]} | ${s[1] || ''}`;
                    if (!nodeMap.has(supporterId)) {
                        nodeMap.set(supporterId, { id: supporterId, label: s[0], sublabel: s[1] || '', type: 'supporter', color: supporterColor, linkCount: 0, font: this.defaultFont });
                    }
                    links.push({ source: aea, target: supporterId, weight: 1 });
                    nodeMap.get(aea).linkCount += 1;
                    nodeMap.get(supporterId).linkCount += 1;
                });
            });
        } else if (this.data.support_map) {
            Object.entries(this.data.support_map).forEach(([aea, val]) => {
                if (!nodeMap.has(aea)) {
                    nodeMap.set(aea, { id: aea, label: aea, type: 'antrag', color: antragColor, linkCount: 0, font: this.defaultFont });
                }
                if (Array.isArray(val)) {
                    val.forEach(s => {
                        const supporterId = `${s[0]} | ${s[1] || ''}`;
                        if (!nodeMap.has(supporterId)) nodeMap.set(supporterId, { id: supporterId, label: s[0], sublabel: s[1] || '', type: 'supporter', color: supporterColor, linkCount: 0, font: this.defaultFont });
                        links.push({ source: aea, target: supporterId, weight: 1 });
                        nodeMap.get(aea).linkCount += 1;
                        nodeMap.get(supporterId).linkCount += 1;
                    });
                } else if (val && typeof val === 'object') {
                    const app = val.initiator;
                    if (Array.isArray(app)) {
                        const supporterId = `${app[0]} | ${app[1] || ''}`;
                        if (!nodeMap.has(supporterId)) nodeMap.set(supporterId, { id: supporterId, label: app[0], sublabel: app[1] || '', type: 'supporter', color: supporterColor, linkCount: 0, font: this.defaultFont });
                        links.push({ source: aea, target: supporterId, weight: 5 });
                        nodeMap.get(aea).linkCount += 100;
                        nodeMap.get(supporterId).linkCount += 100;
                    }
                    (val.supporters || []).forEach(s => {
                        const supporterId = `${s[0]} | ${s[1] || ''}`;
                        if (!nodeMap.has(supporterId)) nodeMap.set(supporterId, { id: supporterId, label: s[0], sublabel: s[1] || '', type: 'supporter', color: supporterColor, linkCount: 0, font: this.defaultFont });
                        links.push({ source: aea, target: supporterId, weight: 1 });
                        nodeMap.get(aea).linkCount += 1;
                        nodeMap.get(supporterId).linkCount += 1;
                    });
                }
            });
        }

        this.nodes = Array.from(nodeMap.values());
        // Attach node refs to links
        this.links = links.map(l => ({ ...l }));

        this.allNodes = [...this.nodes];
        this.allLinks = [...this.links];

        this.adj = new Map();
        this.nodes.forEach(n => this.adj.set(n.id, new Set()));
        this.links.forEach(l => {
            const a = l.source.id || l.source;
            const b = l.target.id || l.target;
            if (this.adj.has(a)) this.adj.get(a).add(b);
            if (this.adj.has(b)) this.adj.get(b).add(a);
        });
    }

    async simulatePhysics() {
        const urlParams = new URLSearchParams(window.location.search);
        const project = urlParams.get('project') || 'bdk';
        const initialNodeId = urlParams.get('node');

        let res = await fetch(`/data/${project}/simulated/nodes.json`);
        if (!res.ok) {
            // Fallback to root if simulated/ doesn't exist
            res = await fetch(`/data/${project}/nodes.json`);
        }
        
        if (res.ok) {
            const nodesData = await res.json();
            const byId = new Map(this.nodes.map(n => [n.id, n]));
            nodesData.forEach(p => {
                const n = byId.get(p.id);
                if (!n) return;
                n.x = p.x;
                n.y = p.y;
                n.vx = p.vx;
                n.vy = p.vy;
            });
        } else {
            console.warn(`Could not load nodes.json for project ${project}. Using default positions.`);
        }
        const nodeRef = new Map(this.nodes.map(n => [n.id, n]));
        this.links = this.links
            .map(l => {
                const a = l.source.id || l.source;
                const b = l.target.id || l.target;
                const sa = nodeRef.get(a);
                const sb = nodeRef.get(b);
                if (!sa || !sb) return null;
                return { source: sa, target: sb, weight: l.weight || 1 };
            })
            .filter(Boolean);
        this.allNodes = [...this.nodes];
        this.allLinks = [...this.links];
        this.adj = new Map();
        this.nodes.forEach(n => this.adj.set(n.id, new Set()));
        this.links.forEach(l => {
            const a = l.source.id || l.source;
            const b = l.target.id || l.target;
            if (this.adj.has(a)) this.adj.get(a).add(b);
            if (this.adj.has(b)) this.adj.get(b).add(a);
        });

        const loadingOverlay = document.getElementById('loading');
        if (loadingOverlay) loadingOverlay.style.display = 'none';

        this.render();
        
        if (initialNodeId) {
            const targetNode = this.nodes.find(n => n.id === initialNodeId);
            if (targetNode) {
                this.onNodeClick({ stopPropagation: () => { } }, targetNode);
                this.centerOnNode(targetNode);
            } else {
                this.centerGraph();
            }
        } else {
            this.centerGraph();
        }

        // Dispatch data loaded event for React
        window.dispatchEvent(new CustomEvent('aea-data-loaded', {
            detail: {
                nodes: this.allNodes,
                links: this.allLinks,
                metadata: this.metadata
            }
        }));
    }

    setupEventListeners() {
        if (this.eventsInitialized) return;
        this.eventsInitialized = true;

        window.addEventListener('resize', () => this.onResize());

        // Listen for filter changes from React
        window.addEventListener('aea-filter-change', (e) => {
            const { type, value } = e.detail;
            if (type === 'showAntraege') {
                this.settings.showAntraege = value;
                this.applyFilters();
            }
            if (type === 'showSupporters') {
                this.settings.showSupporters = value;
                this.applyFilters();
            }
            if (type === 'showLabels') {
                this.settings.showLabels = value;
                this.updateLabelVisibility();
                this.render();
            }
            if (type === 'showLinks') {
                this.settings.showLinks = value;
                this.render();
            }
            if (type === 'nodeSize') {
                this.settings.nodeSize = parseFloat(value);
                this.render();
            }
        });

        // Listen for view actions from React
        window.addEventListener('aea-view-action', (e) => {
            const { action, nodeId } = e.detail;
            if (action === 'reset') this.resetView();
            if (action === 'center' && nodeId) {
                const node = this.allNodes.find(n => n.id === nodeId);
                if (node) this.centerOnNode(node);
            }
            if (action === 'highlight' && nodeId) {
                this.highlightNode(nodeId);
            }
        });

        // Listen for group updates from React
        window.addEventListener('aea-group-update', (e) => {
            const { groups } = e.detail;
            this.updateGroups(groups);
        });

        // Listen for density updates from React
        window.addEventListener('aea-density-update', (e) => {
            const { groupId, opacity, dimming, blur } = e.detail;
            this.updateDensitySettings(groupId, opacity, dimming, blur);
        });
    }

    updateDensitySettings(groupId, opacity, dimming, blur) {
        this.densityGroupId = groupId;
        this.densityOpacity = opacity;
        this.graphDimming = dimming || 0;
        this.contourBlur = blur || 0;
        this.computeDensity();
        this.render();
    }

    updateGroups(groups) {
        this.groups = groups || [];
        this.nodeGroups = new Map();
        
        this.groups.forEach(group => {
            if (group.nodes && Array.isArray(group.nodes)) {
                group.nodes.forEach(nodeId => {
                    // Note: Last group wins if a node is in multiple groups
                    this.nodeGroups.set(nodeId, group.id);
                });
            }
        });
        
        // Re-compute density if the selected density group was updated
        if (this.densityGroupId) {
            this.computeDensity();
        }

        this.render();
    }
    
    computeDensity() {
        this.densityContours = null;
        if (!this.densityGroupId) return;

        const group = this.groups.find(g => g.id === this.densityGroupId);
        if (!group || !group.nodes || group.nodes.length < 3) return; // Need a few points for density

        const nodes = this.allNodes.filter(n => group.nodes.includes(n.id));
        if (nodes.length === 0) return;

        // Calculate bounding box
        const xExtent = d3.extent(nodes, d => d.x);
        const yExtent = d3.extent(nodes, d => d.y);
        
        // Add padding
        const padding = 50;
        const width = xExtent[1] - xExtent[0] + padding * 2;
        const height = yExtent[1] - yExtent[0] + padding * 2;
        
        // Shift nodes to positive coordinates for calculation
        const offsetX = xExtent[0] - padding;
        const offsetY = yExtent[0] - padding;

        const contourDensity = d3.contourDensity()
            .x(d => d.x - offsetX)
            .y(d => d.y - offsetY)
            .weight(d => Math.sqrt(d.linkCount || 1))
            .size([width, height])
            .bandwidth(30) // Adjust for smoothness
            .thresholds(20);

        const contours = contourDensity(nodes);
        
        // Store contours and offset for rendering
        this.densityContours = {
            paths: contours,
            offsetX: offsetX,
            offsetY: offsetY,
            color: group.color
        };
    }

    applyFilters() {
        this.nodes = this.allNodes.filter(n => {
            if (n.type === 'antrag' && !this.settings.showAntraege) return false;
            if (n.type === 'supporter' && !this.settings.showSupporters) return false;
            return true;
        });

        const nodeIds = new Set(this.nodes.map(n => n.id));
        this.links = this.allLinks.filter(l =>
            nodeIds.has(l.source.id) && nodeIds.has(l.target.id)
        );

        this.render();
    }

    render() {
        const ctx = this.ctx;
        if (!ctx) return;
        ctx.save();
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.translate(this.transform.x, this.transform.y);
        ctx.scale(this.transform.k, this.transform.k);

        const linkColor = getComputedStyle(document.documentElement).getPropertyValue('--link-color').trim() || 'rgba(153,153,153,0.3)';

        const isDimmed = (node) => {
            if (!this.selectedNode) return false;
            if (node.id === this.selectedNode.id) return false;
            const neighbors = this.adj && this.adj.get(this.selectedNode.id);
            if (!neighbors) return true;
            return !neighbors.has(node.id);
        };

        if (this.settings.showLinks) {
            ctx.strokeStyle = linkColor;
            this.links.forEach(l => {
                if (l.source.x === undefined || l.source.y === undefined || l.target.x === undefined || l.target.y === undefined) return;
                
                ctx.save();
                const dim = this.selectedNode && l.source.id !== this.selectedNode.id && l.target.id !== this.selectedNode.id;
                ctx.globalAlpha = (dim ? 0.15 : 1.0) * (1 - (this.graphDimming || 0));
                ctx.lineWidth = (l.weight || 1) * 1;
                ctx.beginPath();
                ctx.moveTo(l.source.x, l.source.y);
                ctx.lineTo(l.target.x, l.target.y);
                ctx.stroke();
                ctx.restore();
            });
        }

        this.nodes.forEach(n => {
            if (n.x === undefined || n.y === undefined) return;
            
            const radius = (Math.sqrt(n.linkCount || 0) * 1.5 + 0.25) * this.settings.nodeSize;
            ctx.save();
            ctx.globalAlpha = (isDimmed(n) ? 0.2 : 1.0) * (1 - (this.graphDimming || 0));
            ctx.fillStyle = this.getNodeColor(n);
            ctx.beginPath();
            ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            const showLabel = this.settings.showLabels || n === this.selectedNode || n === this.hoveredNode || (this.selectedNode && this.adj && this.adj.get(this.selectedNode.id) && this.adj.get(this.selectedNode.id).has(n.id));
            if (showLabel) {
                ctx.save();
                ctx.globalAlpha = 1 - (this.graphDimming || 0);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-000-full').trim() || '#faf9f5';
                ctx.font = '16px ' + (this.getFontClass(n.font).includes('serif') ? 'Serif' : 'ModernDense');
                ctx.textBaseline = 'middle';
                ctx.fillText(n.label, n.x + radius + 5, n.y);
                if (n.sublabel) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-400-full').trim() || '#9c9a92';
                    ctx.font = '12px ' + (this.getFontClass(n.font).includes('serif') ? 'Serif' : 'ModernDense');
                    ctx.fillText(n.sublabel, n.x + radius + 5, n.y + 12);
                }
                ctx.restore();
            }
        });

        // Render Density Contours (Overlay)
        if (this.densityContours && this.densityContours.paths) {
            const { paths, offsetX, offsetY, color } = this.densityContours;
            const geoPath = d3.geoPath(null, ctx);
            
            ctx.save();
            
            // Apply blur filter if specified
            if (this.contourBlur > 0) {
                ctx.filter = `blur(${this.contourBlur}px)`;
            }

            // We need to translate back to world coordinates
            // But since the paths are already in pixel coordinates relative to [0,0] of the density box
            // which corresponds to [offsetX, offsetY] in world space
            // we translate the context.
            ctx.translate(offsetX, offsetY);
            
            paths.forEach(contour => {
                ctx.beginPath();
                geoPath(contour);
                ctx.fillStyle = color;
                // Use density value for opacity scaling if desired, or just global opacity
                // contour.value is the density estimate
                ctx.globalAlpha = (this.densityOpacity || 0.5) * 0.15; // Increased base opacity scaling
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.globalAlpha = (this.densityOpacity || 0.5) * 0.6; // More direct mapping for stroke
                ctx.stroke();
            });
            
            ctx.restore();
        }

        ctx.restore();
    }

    onNodeClick(event, d) {
        if (event && event.sourceEvent) {
            event.sourceEvent.stopPropagation();
        } else if (event && event.stopPropagation) {
            event.stopPropagation();
        }
        
        if (event && event.preventDefault) {
            event.preventDefault();
        }

        this.selectedNode = d;

        // Dispatch custom event for React to pick up
        window.dispatchEvent(new CustomEvent('aea-node-selected', {
            detail: {
                node: d,
                metadata: {
                    url: this.motionUrlMap[d.id],
                    pdfPath: d.type === 'antrag' ? `./data_gathering/pdf/${this.sanitizeFilename(d.id)}.pdf` : null
                }
            }
        }));

        this.render();
    }

    showNodeContextMenu(event, d) {
        const rect = this.canvas.node().getBoundingClientRect();
        const clientX = event.touches && event.touches.length ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches && event.touches.length ? event.touches[0].clientY : event.clientY;

        window.dispatchEvent(new CustomEvent('aea-context-menu', {
            detail: {
                node: d,
                x: clientX,
                y: clientY
            }
        }));
    }

    onNodeHover(event, d) {
        this.hoveredNode = d;
        this.updateLabelVisibility();
    }

    onNodeLeave() {
        this.hoveredNode = null;
        this.updateLabelVisibility();
    }

    getNodeColor(node) {
        const groupId = this.nodeGroups.get(node.id);
        if (groupId !== undefined) {
            const group = this.groups.find(g => g.id === groupId);
            if (group) return group.color;
        }
        return node.color;
    }

    onNodeRightClick(event, d) {
        event.preventDefault();
        // Context menu removed for now, can be re-added as React component if needed
    }

    updateLabelVisibility() { }

    onResize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.attr('width', this.width).attr('height', this.height);
        this.render();
    }

    highlightNode(nodeId) {
        const node = this.allNodes.find(n => n.id === nodeId);
        if (node) {
            // Ensure the node is visible by checking filters
            let needsFilterUpdate = false;
            if (node.type === 'antrag' && !this.settings.showAntraege) {
                this.settings.showAntraege = true;
                needsFilterUpdate = true;
            }
            if (node.type === 'supporter' && !this.settings.showSupporters) {
                this.settings.showSupporters = true;
                needsFilterUpdate = true;
            }
            if (needsFilterUpdate) this.applyFilters();

            this.centerOnNode(node);
            this.onNodeClick({ stopPropagation: () => { } }, node);
        }
    }

    resetView() {
        this.deselectAll();
        this.settings.showAntraege = true;
        this.settings.showSupporters = true;
        this.applyFilters();
        this.canvas.transition()
            .duration(750)
            .call(this.zoom.transform, d3.zoomIdentity);
        this.centerGraph();
    }

    centerGraph() {
        const positionedNodes = this.nodes.filter(n => n.x !== undefined && n.y !== undefined);
        if (positionedNodes.length === 0) return;

        const centerX = positionedNodes.reduce((sum, n) => sum + n.x, 0) / positionedNodes.length;
        const centerY = positionedNodes.reduce((sum, n) => sum + n.y, 0) / positionedNodes.length;

        const transform = d3.zoomIdentity
            .translate(this.width / 2, this.height / 2)
            .translate(-centerX, -centerY);

        this.canvas.transition()
            .duration(750)
            .call(this.zoom.transform, transform);
    }

    centerOnNode(node) {
        const transform = d3.zoomIdentity
            .translate(this.width / 2, this.height / 2)
            .translate(-node.x, -node.y);
        this.canvas.transition()
            .duration(750)
            .call(this.zoom.transform, transform);
    }

    findNodeAt(event) {
        if (!this.nodes || this.nodes.length === 0) return null;

        const canvasNode = this.canvas.node();
        if (!canvasNode) return null;

        const [px, py] = d3.pointer(event, canvasNode);
        const [worldX, worldY] = this.transform.invert([px, py]);

        // Hit detection threshold in screen pixels, scaled to world space
        const threshold = 8 / this.transform.k;

        return this.nodes.find(node => {
            if (node.x === undefined || node.y === undefined) return false;
            
            const dx = node.x - worldX;
            const dy = node.y - worldY;
            const distanceSquared = dx * dx + dy * dy;
            
            // Match the radius calculation in render()
            const radius = (Math.sqrt(node.linkCount || 0) * 1.5 + 0.25) * this.settings.nodeSize;
            const hitRadius = radius + threshold;
            
            return distanceSquared <= hitRadius * hitRadius;
        });
    }

    sanitizeFilename(name) {
        return String(name).replace(/[<>:\"/\\|?*]/g, '_').trim();
    }
}

// Export for Svelte
if (typeof window !== 'undefined') {
    window.GraphVisualization = GraphVisualization;
}
